import tensorflow as tf

NUM_SIZE_CHANNELS = 2
NUM_OFFSET_CHANNELS = 2

def _construct_prediction_heads(num_classes, num_feature_outputs,
                                  class_prediction_bias_init):
    """Constructs the prediction heads based on the specific parameters.
    Args:
      num_classes: An integer indicating how many classes in total to predict.
      num_feature_outputs: An integer indicating how many feature outputs to use
        for calculating the loss. The Objects as Points paper attaches loss
        functions to multiple (`num_feature_outputs`) feature maps in the the
        backbone. E.g. for the hourglass backbone, `num_feature_outputs` is 2.
      class_prediction_bias_init: float, the initial value of bias in the
        convolutional kernel of the class prediction head. If set to None, the
        bias is initialized with zeros.
    Returns:
      A dictionary of keras modules generated by calling make_prediction_net
      function. It will also create and set a private member of the class when
      learning the tracking task.
    """
    prediction_heads = {}
    prediction_heads['ct_heatmaps'] = _make_prediction_net_list(
        num_feature_outputs,
        num_classes,
        kernel_sizes=(3),
        num_filters=(256),
        bias_fill=class_prediction_bias_init,
        name='center')

    prediction_heads['ct_size'] = _make_prediction_net_list(
        num_feature_outputs, NUM_SIZE_CHANNELS, name='box_scale')
    prediction_heads['ct_offset'] = _make_prediction_net_list(
        num_feature_outputs, NUM_OFFSET_CHANNELS, name='box_offset')

    return prediction_heads


def make_prediction_net(num_out_channels, kernel_sizes=(3), num_filters=(256),
                        bias_fill=None, use_depthwise=False, name=None):
  """Creates a network to predict the given number of output channels.
  This function is intended to make the prediction heads for the CenterNet
  meta architecture.
  Args:
    num_out_channels: Number of output channels.
    kernel_sizes: A list representing the sizes of the conv kernel in the
      intermediate layer. Note that the length of the list indicates the number
      of intermediate conv layers and it must be the same as the length of the
      num_filters.
    num_filters: A list representing the number of filters in the intermediate
      conv layer. Note that the length of the list indicates the number of
      intermediate conv layers.
    bias_fill: If not None, is used to initialize the bias in the final conv
      layer.
    use_depthwise: If true, use SeparableConv2D to construct the Sequential
      layers instead of Conv2D.
    name: Optional name for the prediction net.
  Returns:
    net: A keras module which when called on an input tensor of size
      [batch_size, height, width, num_in_channels] returns an output
      of size [batch_size, height, width, num_out_channels]
  """
  if isinstance(kernel_sizes, int) and isinstance(num_filters, int):
    kernel_sizes = [kernel_sizes]
    num_filters = [num_filters]
  assert len(kernel_sizes) == len(num_filters)
  if use_depthwise:
    conv_fn = tf.keras.layers.SeparableConv2D
  else:
    conv_fn = tf.keras.layers.Conv2D

  # We name the convolution operations explicitly because Keras, by default,
  # uses different names during training and evaluation. By setting the names
  # here, we avoid unexpected pipeline breakage in TF1.
  out_conv = tf.keras.layers.Conv2D(
      num_out_channels,
      kernel_size=1)

  if bias_fill is not None:
    out_conv.bias_initializer = tf.keras.initializers.constant(bias_fill)

  layers = []
  for idx, (kernel_size,
            num_filter) in enumerate(zip(kernel_sizes, num_filters)):
    layers.append(
        conv_fn(
            num_filter,
            kernel_size=kernel_size,
            padding='same'))
    layers.append(tf.keras.layers.ReLU())
  layers.append(out_conv)
  net = tf.keras.Sequential(layers, name=name)
  return net

def _make_prediction_net_list(num_feature_outputs, num_out_channels,
                                kernel_sizes=(3), num_filters=(256),
                                bias_fill=None, name=None):
    prediction_net_list = []
    for i in range(num_feature_outputs):
      prediction_net_list.append(
          make_prediction_net(
              num_out_channels,
              kernel_sizes=kernel_sizes,
              num_filters=num_filters,
              bias_fill=bias_fill,
              use_depthwise=False,
              name='{}_{}'.format(name, i) if name else name))
    return prediction_net_list
